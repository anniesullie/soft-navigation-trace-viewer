<!DOCTYPE html>
<html>
<body>
  <template id="filmstrip-screenshot-template">
    <style>
      .container {
        position: relative;
      }

      .screenshot {
        display: block;
      }

      .lcp {
        display: none;
      }

      .lcp.highlighted {
        display: block;
        z-index: 10;
        position: absolute;
        background-color: rgba(255, 255, 0, 0.75);
      }

      .tooltip {
        display: none;
      }

      .lcp.highlighted:hover .tooltip {
        z-index: 1000;
        display: block;
        position: absolute;
        top: 50%; /* Vertically center */
        left: 50%; /* Horizontally center */
        transform: translate(-50%, -50%); /* Adjust for element's own size */
        width: 300px;
        padding: 10px;
        border-radius: 10px;
        background-color: yellow;
        color: black;
        border: 2px solid black;
        text-align: center;
        overflow-wrap: anywhere;
      }

      #image-url[url=None],
      span[final=false] {
        display: none;
      }
    </style>
    <div class="container">
      <img class="screenshot">
      <div class="lcp">
        <div class="tooltip">
          <p><strong>LCP Element <span id="final" final="false">(Final)</span></strong></p>
          <p>Type: <span id="type"></span></p>
          <p id="image-url" url="None"><a id="url" href="" target="_blank"></a></p>
          <p>Size: <span id="size"></span></p>
        </div>
      </div>
    </div>
  </template>
  <template id="filmstrip-soft-navigation-start-template">
    <style>
      .container {
        height: 100%;
        position: relative;
      }

      .startblock {
        width: 40px;
        height: 100%;
        background-color: #4CAF50;
      }

      .container[lcp=false] .startblock {
        background-color: #F44336;
      }

      .tooltip {
        display: none;
      }

      .container:hover .tooltip {
        z-index: 1000;
        display: block;
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        left: 10px;
        width: 300px;
        padding: 10px;
        border-radius: 10px;
        background-color: #4CAF50;
        color: white;
        border: 2px solid white;
        text-align: center;
        overflow-wrap: anywhere;
      }

      .container:hover[lcp=false] .tooltip {
        background-color: #F44336;
      }

      .lcp-error {
        display: none;
      }

      .container:hover[lcp=false] .tooltip .lcp-error {
        display: inline;
      }
    </style>
    <div class="container">
      <div class="startblock"></div>
      <div class="tooltip">
        <p><strong>Soft Navigation Detected<span class="lcp-error"> - No LCP</span></strong></p>
        <p>URL: <a id="url" target="_blank"></a></p>
        <p>Navigation ID: <span id="navigation-id"></span></p>
        <p>Context ID: <span id="context-id"></span></p>
        <p>DOM Modifications: <span id="dom-modifications"></span></p>
        <p>Painted Area: <span id="painted-area"></span></p>
      </div>
    </div>
  </template>
  <template id="timeline-timestamp">
    <style>
      .timestamp {
        font-family: sans-serif;
      }
    </style>
    <div class="timestamp"></div>
  </template>
  <template id="trace-timeline-template">
    <style>
      :host([empty]) {
        display: none;
      }

      .container {
        display: grid;
        font-family: sans-serif;
        background-color: black;
        color: white;
        overflow: hidden;
        padding: 15px;
        border-radius: 5px;
      }

      .container::-webkit-scrollbar {
        width: 10px;
        height: 10px;
      }

      .container::-webkit-scrollbar-thumb {
        background: #888;
        border-radius: 5px;
      }

      .container::-webkit-scrollbar-track {
        background-color: black;
      }

      .title {
        justify-self: start;
        font-size: x-large;
        padding: 10px 0 10px;
        grid-row-start: 1;
      }

      #timeline {
        display: grid;
        grid-row-start: 2;
        justify-items: center;
        justify-content: start;
        overflow-x: auto;
      }
      #timeline::-webkit-scrollbar {
        -webkit-appearance: none;
      }

      #timeline::-webkit-scrollbar:horizontal {
        height: 11px;
      }

      #timeline::-webkit-scrollbar-thumb {
        border-radius: 8px;
        border: 2px solid white;
        background-color: rgba(0, 0, 0, .5);
      }
      #timeline::-webkit-scrollbar-track { 
        background-color: #fff; 
        border-radius: 8px; 
      }

      #timeline[compressed]>filmstrip-screenshot:not([has-lcp]) {
        display: none;
      }

      #timeline[compressed]>filmstrip-screenshot:not([has-lcp])+timeline-timestamp {
        display: none;
      }

      input[type=checkbox] {
        margin: 10px;
      }

      label:hover {
        color: #2196F3;
      }

      label:hover>input {
        box-shadow: 0 0 3px 3px #2196F3;
      }

      filmstrip-screenshot {
        border: 3px solid yellow;
        margin-left: 2px;
        margin-right: 2px;
      }

      filmstrip-soft-navigation-start {
        margin-left: 2px;
        margin-right: 2px;
      }
    </style>
    <div class="container">
      <h1 class="title"></h1>
      <div id="timeline"></div>
      <label for="hide-no-lcp"><input type="checkbox" id="hide-no-lcp">Hide screenshots that are not LCP
        candidates</label>
    </div>
  </template>
  <template id="drop-target-template">
    <style>
      .container {
        width: 100vw;
        height: 100vh;
        display: grid;
        place-content: center;
        font-family: sans-serif;
      }

      .container.secondary {
        width: fit-content;
        height: fit-content;
        padding: 20px;
      }

      #file-input {
        display: none;
      }

      .drop-target-content {
        border: 2px dashed;
        border-radius: 10px;
        width: 800px;
        height: 500px;
        display: grid;
        place-content: center;
        justify-items: center;
        padding: 20px;
      }

      .drop-target-content:hover {
        background-color: #2196F3;
      }

      .drop-target-content:hover #upload-icon {
        fill: white;
      }
      .drop-target-content:hover #instructions {
        color: white;
      }

      .secondary .drop-target-content {
        width: 200px;
        height: 200px;
      }

      .drop-icon {
        width: 200px;
        height: 200px;
      }

      .secondary .drop-icon {
        width: 100px;
        height: 100px;
      }

      .error .drop-target-content {
        background-color: #FFCDD2;
        color: #F44336;
        border-color: #D32F2F;
      }

      #drop-error {
        display: none;
      }

      .error #drop-error, #instructions {
        display: inline-block;
        font-size: xx-large;
        text-align: center;
        margin: 20px;
      }

      .secondary.error #drop-error, .secondary #instructions {
        font-size: medium;
      }

      .error #upload-icon {
        fill: #F44336 !important;
      }

      .error #instructions {
        display: none;
      }
    </style>
    <div class="container">
      <input id="file-input" type="file">
      <label for="file-input" class="drop-target-content">
        <svg class="drop-icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 -960 960 960">
          <path id="upload-icon"
            d="M440-320v-326L336-542l-56-58 200-200 200 200-56 58-104-104v326h-80ZM240-160q-33 0-56.5-23.5T160-240v-120h80v120h480v-120h80v120q0 33-23.5 56.5T720-160H240Z" />
        </svg>
        <div id="drop-error"></div>
        <div id="instructions">Record a trace, save it, and drop the .json file here.
          <a href="https://github.com/anniesullie/soft-navigation-trace-viewer/blob/main/README.md" target="_blank">Full instructions</a>.</div>
      </label>
    </div>
  </template>
  <script>

    const filmstripSoftNavigationStartTemplateContent = document.getElementById("filmstrip-soft-navigation-start-template").content;
    const filmstripScreenshotTemplateContent = document.getElementById("filmstrip-screenshot-template").content;
    const timelineTimestampTemplateContent = document.getElementById("timeline-timestamp").content;
    const traceTimelineTemplateContent = document.getElementById("trace-timeline-template").content;
    const dropTargetTemplateContent = document.getElementById("drop-target-template").content;

    class FilmstripSoftNavigationStart extends HTMLElement {
      #navigationId;
      #url;
      #contextId;
      #domModifications;
      #paintedArea;

      connectedCallback() {
        const shadowRoot = this.attachShadow({ mode: "open" });
        shadowRoot.appendChild(filmstripSoftNavigationStartTemplateContent.cloneNode(true));
        this.updateTooltip();
      }

      set navigationId(navigationId) {
        this.#navigationId = navigationId;
        this.updateTooltip();
      }

      set url(url) {
        this.#url = url;
        this.updateTooltip();
      }

      set contextId(contextId) {
        this.#contextId = contextId;
        this.updateTooltip();
      }

      set domModifications(domModifications) {
        this.#domModifications = domModifications;
        this.updateTooltip();
      }

      set paintedArea(paintedArea) {
        this.#paintedArea = paintedArea;
        this.updateTooltip();
      }

      set hasLcp(lcp) {
        // Ensure shadowRoot is available
        if (this.shadowRoot) {
          this.shadowRoot.querySelector('.container').setAttribute("lcp", String(lcp));
        } else {
          // Defer if shadowRoot is not yet available (e.g., if called before connectedCallback)
          Promise.resolve().then(() => this.shadowRoot.querySelector('.container').setAttribute("lcp", String(lcp)));
        }
      }

      updateTooltip() {
        if (!this.shadowRoot) {
          return;
        }
        let url = this.shadowRoot.querySelector('#url');
        url.setAttribute('href', this.#url ?? '');
        url.textContent = this.#url ?? '';
        let navigationId = this.shadowRoot.querySelector('#navigation-id');
        navigationId.textContent = this.#navigationId ?? '';
        let contextId = this.shadowRoot.querySelector('#context-id');
        contextId.textContent = this.#contextId ?? '';
        let domModifications = this.shadowRoot.querySelector('#dom-modifications');
        domModifications.textContent = this.#domModifications ?? 0;
        let paintedArea = this.shadowRoot.querySelector('#painted-area');
        paintedArea.textContent = this.#paintedArea ?? 0;
      }
    }

    class FilmstripScreenshot extends HTMLElement {
      #viewport;
      #lcpData;
      #src;

      connectedCallback() {
        const shadowRoot = this.attachShadow({ mode: "open" });
        shadowRoot.appendChild(filmstripScreenshotTemplateContent.cloneNode(true));
        this.updateSrc();
        this.updateLcpRect();
      }

      set viewport(viewport) {
        this.#viewport = viewport;
      }

      set lcpData(lcpData) {
        this.#lcpData = lcpData;
        this.updateLcpRect();
        this.setAttribute("has-lcp", "true");
      }

      set src(src) {
        this.#src = `data:image/png;base64,${src}`;
        this.updateSrc();
      }

      set final(final) {
        if (this.shadowRoot) {
          this.shadowRoot.querySelector('#final').setAttribute("final", String(final));
        }
      }

      updateSrc() {
        if (!this.shadowRoot || !this.#src) {
          return;
        }
        let el = this.shadowRoot.querySelector('.screenshot');
        if (el) {
          el.src = this.#src;
          el.addEventListener('load', this.updateLcpRect.bind(this));
        }
      }

      updateLcpRect() {
        if (!this.shadowRoot || !this.#viewport || !this.#lcpData) {
          return;
        }
        // Rect is p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y.
        let left = this.#lcpData.rect[0];
        let top = this.#lcpData.rect[1];
        let width = this.#lcpData.rect[2] - left;
        let height = this.#lcpData.rect[5] - top;
        // Adjust to screenshot dimensions by converting to fraction of the
        //  viewport and multiplying by screenshot width and height.
        let img = this.shadowRoot.querySelector('.screenshot');
        left = (left / this.#viewport.width) * img.clientWidth;
        top = (top / this.#viewport.height) * img.clientHeight;
        width = (width / this.#viewport.width) * img.clientWidth;
        height = (height / this.#viewport.height) * img.clientHeight;
        let lcpElement = this.shadowRoot.querySelector('.lcp');
        lcpElement.style.top = `${top}px`;
        lcpElement.style.left = `${left}px`;
        lcpElement.style.width = `${width}px`;
        lcpElement.style.height = `${height}px`;
        lcpElement.classList.add('highlighted');
        this.shadowRoot.querySelector('#type').textContent = this.#lcpData.type;
        this.shadowRoot.querySelector('#size').textContent = this.#lcpData.size;
        this.shadowRoot.querySelector('#image-url').setAttribute('url', this.#lcpData.url ?? 'None');
        let a = this.shadowRoot.querySelector('#url');
        a.href = this.#lcpData.url ?? '';
        a.textContent = this.#lcpData.url ?? '';
      }
    }

    class TimelineTimestamp extends HTMLElement {
      #timestamp;

      connectedCallback() {
        const shadowRoot = this.attachShadow({ mode: "open" });
        shadowRoot.appendChild(timelineTimestampTemplateContent.cloneNode(true));
        this.updateTimestamp();
      }

      set timestamp(timestamp) {
        this.#timestamp = timestamp;
        this.updateTimestamp();
      }

      updateTimestamp() {
        if (!this.shadowRoot || this.#timestamp == null) {
          return;
        }
        let el = this.shadowRoot.querySelector('.timestamp');
        if (el) {
          el.textContent = this.timestamp_;
        }
      }

    }

    const TRACE_EVENT_NAMES = {
      SCREENSHOT: 'Screenshot',
      LCP_CANDIDATE: 'largestContentfulPaint::Candidate',
      SOFT_NAV_DETECTED: 'SoftNavigationHeuristics_SoftNavigationDetected',
      TRACING_STARTED: 'TracingStartedInBrowser',
      VIEWPORT: 'PaintTimingVisualizer::Viewport',
      LAYOUT_OBJECT_PAINTED: 'PaintTimingVisualizer::LayoutObjectPainted',
      SOFT_NAV_CONTEXT_CREATED: "SoftNavigationHeuristics::CreateNewContext",
      SOFT_NAV_CONTEXT_FIRST_MODIFIED_NODE: "SoftNavigationContext::FirstAddedModifiedNodeInAnimationFrame",
      SOFT_NAV_CONTEXT_MODIFIED_NODE: "SoftNavigationContext::AddedModifiedNodeInAnimationFrame",
    };

    class TraceTimeline extends HTMLElement {
      connectedCallback() {
        const shadowRoot = this.attachShadow({ mode: "open" });
        shadowRoot.appendChild(traceTimelineTemplateContent.cloneNode(true));
        shadowRoot.querySelector('#hide-no-lcp').addEventListener('change', this.onchange.bind(this));
      }

      onchange(event) {
        const isChecked = event.target.checked;
        this.shadowRoot.querySelector('#timeline').toggleAttribute('compressed', isChecked);
      }

      #setGridCss(element, row, column) {
        element.style.gridRowStart = row;
        element.style.gridColumnStart = column;
      }
      set title(title) {
        this.shadowRoot.querySelector('.title').textContent = title;
      }

      setGridCss(element, row, column) {
        element.style.gridRowStart = row;
        element.style.gridColumnStart = column;
      }

      set traceData(traceData) {
        // Clear previous timeline
        this.removeAttribute('empty');
        let timelineContainer = this.shadowRoot.querySelector('#timeline');
        timelineContainer.replaceChildren();
        // Parse trase JSON from text data
        let traceJson = JSON.parse(traceData);
        let traceEvents = traceJson.traceEvents;
        traceEvents.sort((a, b) => a.ts - b.ts);
        // Tracing Started event has original URL in args.data.frames[0].url
        let traceStartedEvent = traceEvents.find((e) => e.name == TRACE_EVENT_NAMES.TRACING_STARTED);
        let startUrl = traceStartedEvent?.args?.data?.frames?.[0]?.url ?? 'Unknown URL';

        this.title = `Soft navigations from ${startUrl}`;
        // Find viewport rect
        let viewportEvent = traceEvents.find((e) => e.name == TRACE_EVENT_NAMES.VIEWPORT);
        if (!viewportEvent) {
          throw new Error('No PaintTimingVisualizer::Viewport event in trace.');
        }
        let viewport = {
          width: viewportEvent.args.data.viewport_rect[2], // x2
          height: viewportEvent.args.data.viewport_rect[5] // y3 (assuming rect is x1,y1,x2,y1,x2,y2,x1,y2)
        };
        // Cache paint events for LCP candidate nodes
        let lcpNodeIds = new Set(traceEvents.flatMap(e =>
          (e.name === TRACE_EVENT_NAMES.LCP_CANDIDATE && e.args?.data?.nodeId) ? [e.args.data.nodeId] : []
        ));
        let lcpPaintEvents = traceEvents.filter(e =>
          e.name === TRACE_EVENT_NAMES.LAYOUT_OBJECT_PAINTED && e.args?.data && lcpNodeIds.has(e.args.data.dom_node_id)
        );
        // Filter to relevant trace events
        traceEvents = traceEvents.filter((e) => [
          TRACE_EVENT_NAMES.SCREENSHOT,
          TRACE_EVENT_NAMES.LCP_CANDIDATE,
          TRACE_EVENT_NAMES.SOFT_NAV_DETECTED
        ].includes(e.name));
        // Find the first soft navigation event.
        let firstSoftNavIndex = traceEvents.findIndex((e) => e.name == TRACE_EVENT_NAMES.SOFT_NAV_DETECTED);
        if (firstSoftNavIndex == -1) {
          throw new Error('No soft navigations found in trace!');
        }
        // Clip frames to the first one before the soft nav.
        let index = 0;
        for (index = firstSoftNavIndex - 1; index >= 0; index--) {
          if (traceEvents[index].name == TRACE_EVENT_NAMES.SCREENSHOT) {
            break;
          }
        }
        traceEvents.splice(0, index);
        let timeStart = traceEvents[0].ts;
        let lastSnapshot = null;
        let column = 1;
        let lastSoftNavId = null;
        let nextLcpData = null;
        let lastLcpCandidateScreenshot = null;
        let lastSoftNavStart = null;
        for (let e of traceEvents) {
          let adjustedTimestamp = Math.floor((e.ts - timeStart) / 1000);
          let timestampElement = document.createElement('timeline-timestamp');
          timestampElement.timestamp = adjustedTimestamp;
          this.#setGridCss(timestampElement, 2, column);
          if (e.name == TRACE_EVENT_NAMES.SOFT_NAV_DETECTED) {
            lastSoftNavId = e.args.navigationId;
            let url = e.args?.context?.mostRecentURL;
            let contextId = e.args?.context?.softNavContextId;
            let domModifications = e.args?.context?.domModifications;
            let paintedArea = e.args?.context?.paintedArea;
            let softNavStartElement = document.createElement('filmstrip-soft-navigation-start');
            softNavStartElement.url = url;
            softNavStartElement.navigationId = lastSoftNavId;
            softNavStartElement.contextId = contextId;
            softNavStartElement.domModifications = domModifications;
            softNavStartElement.paintedArea = paintedArea;
            this.#setGridCss(softNavStartElement, 1, column);
            timelineContainer.appendChild(softNavStartElement);
            if (lastLcpCandidateScreenshot) {
              lastLcpCandidateScreenshot.final = "true";
              lastLcpCandidateScreenshot = null;
            } else if (lastSoftNavStart) {
              // No lcp candidate between last soft nav start and now.
              lastSoftNavStart.hasLcp = false;
              lastSoftNavStart = null;
            }
            lastSoftNavStart = softNavStartElement;
          } else if (e.name == TRACE_EVENT_NAMES.LCP_CANDIDATE) {
            if (e.args.data.navigationId != lastSoftNavId) {
              // LCP unrelated to soft navs in this trace.
              continue;
            }
            // Get related paint event with same node id for text/image placement data
            let paintEvent = lcpPaintEvents.find(p => p.args?.data?.dom_node_id === e.args.data.nodeId);
            if (!paintEvent) {
              console.warn(`No paint event for LCP with node id ${e.args.data.nodeId}`);
              continue;
            }
            nextLcpData = {
              'rect': paintEvent.args.data.rect,
              'url': paintEvent.args.data.image_url,
              'size': e.args.data.size,
              'type': e.args.data.type
            }
            continue;
          } else if (e.name == TRACE_EVENT_NAMES.SCREENSHOT) {
            let snapshot = e.args.snapshot;
            if (snapshot == lastSnapshot) {
              // Nothing new painted.
              continue;
            }
            lastSnapshot = snapshot;
            let screenshotElement = document.createElement("filmstrip-screenshot");
            screenshotElement.src = lastSnapshot;
            if (nextLcpData) {
              screenshotElement.lcpData = nextLcpData;
              screenshotElement.viewport = viewport;
              nextLcpData = null;
              lastLcpCandidateScreenshot = screenshotElement;
            }
            this.#setGridCss(screenshotElement, 1, column);
            timelineContainer.append(screenshotElement);
          }
          timelineContainer.appendChild(timestampElement);
          column = column + 1;
        }
        if (lastLcpCandidateScreenshot) {
          lastLcpCandidateScreenshot.final = true;
          lastLcpCandidateScreenshot = null;
        } else if (lastSoftNavStart) {
          // Last soft nav has no LCP candidate
          lastSoftNavStart.hasLcp = false;
        }
      }
    }

    class DropTarget extends HTMLElement {
      connectedCallback() {
        const shadowRoot = this.attachShadow({ mode: "open" });
        shadowRoot.appendChild(dropTargetTemplateContent.cloneNode(true));

        shadowRoot.querySelector(".drop-target-content").addEventListener("dragover", this.handleDragover.bind(this));
        shadowRoot.querySelector(".drop-target-content").addEventListener("drop", this.handleDrop.bind(this));
        shadowRoot.querySelector("#file-input").addEventListener("change", this.handleChange.bind(this));
      }

      handleDragover(event) {
        event.preventDefault();
      }

      handleDrop(event) {
        event.preventDefault();
        this.clearDropError();

        let textPromise = null;
        if (event.dataTransfer.items) {
          // Use DataTransferItemList interface to access the file(s)
          [...event.dataTransfer.items].forEach((item, i) => {
            // If dropped items aren't files, reject them
            if (item.kind === "file") {
              const file = item.getAsFile();
              textPromise = file.text();
            }
          });
        } else {
          // Use DataTransfer interface to access the file(s)
          [...event.dataTransfer.files].forEach((file, i) => {
            textPromise = file.text();
          });
        }
        if (!textPromise) {
          this.showDropError('No trace file dropped');
          return;
        }
        textPromise.then(this.generateTimeline.bind(this)).catch(this.showDropError.bind(this));
      }

      handleChange(event) {
        let file = event.target.files[0];
        file.text().then(this.generateTimeline.bind(this)).catch(this.showDropError.bind(this));
      }

      generateTimeline(text) {
        document.querySelector('trace-timeline').traceData = text;
        this.shadowRoot.querySelector('.container').classList.add('secondary');
      }

      showDropError(message) {
        document.querySelector('trace-timeline').setAttribute('empty', 'true');
        this.shadowRoot.querySelector('#drop-error').textContent = message;
        this.shadowRoot.querySelector('.container').classList.add('error');
        this.shadowRoot.querySelector('.container').classList.remove('secondary');
      }

      clearDropError() {
        this.shadowRoot.querySelector('#drop-error').textContent = '';
        this.shadowRoot.querySelector('.container').classList.remove('error');
      }
    }

    customElements.define(
      "drop-target",
      DropTarget,
    );
    customElements.define(
      "trace-timeline",
      TraceTimeline,
    );
    customElements.define(
      "timeline-timestamp",
      TimelineTimestamp,
    );
    customElements.define(
      "filmstrip-soft-navigation-start",
      FilmstripSoftNavigationStart
    );
    customElements.define(
      "filmstrip-screenshot",
      FilmstripScreenshot
    )
  </script>
  <trace-timeline empty></trace-timeline>
  <drop-target></drop-target>
</body>
</html>
