<!DOCTYPE html>
<html>
  <head>
  <script>
    const CONTEXT_ID_COLORS = [
      '#D32F2F',
      '#C2185B',
      '#7B1FA2',
      '#512DA8',
      '#303F9F',
      '#1976D2',
      '#0288D1',
      '#0097A7',
      '#00796B',
      '#388E3C',
      '#689F38',
      '#AFB42B',
      '#FBC02D',
      '#FFA000',
      '#F57C00',
      '#E64A19'
    ];

    const CONTEXT_ID_HIGHLIGHT_COLORS = [
      '#FF5252',
      '#FF4081',
      '#E040FB',
      '#7C4DFF',
      '#536DFE',
      '#448AFF',
      '#40C4FF',
      '#18FFFF',
      '#64FFDA',
      '#69F0AE',
      '#B2FF59',
      '#EEFF41',
      '#FFFF00',
      '#FFD740',
      '#FFAB40',
      '#FF6E40',
    ];
  </script>
</head>
<body>
  <template id="filmstrip-tooltip-template">
    <style>
      .tooltip {
        display: none;
        z-index: 1000;
        position: absolute;
        top: 0;
        left: 20px;
        transform: translateY(-100%);
        padding: 12px;
        border-radius: 10px;
        opacity: 1;
        color: black;
        border: 2px solid black;
        text-align: center;
        background-color: var(--color);
        white-space: nowrap;
      }

      .tooltip.hover, .tooltip.hoverSticky {
        display: block;
        max-width: 800px;
      }

      .title {
        margin-bottom: 8px;
      }

      .data-grid {
        display: inline-grid;
        grid-template-columns: max-content auto;
        gap: 6px 8px;
        align-items: baseline;
        text-align: left;
      }

      .data-grid .data-label {
        text-align: right;
        max-width: 100px;
        overflow-wrap: break-word;
      }

      .data-grid .data-value {
        overflow-wrap: break-word;
      }

      .data-grid .data-value {
        word-break: break-all;
      }
    </style>
    <div class="tooltip">
      <p class="title"></p>
      <div class="data-grid"></div>
    </div>
  </template>
  <template id="filmstrip-screenshot-template">
    <style>
      .container {
        position: relative;
      }

      .screenshot {
        display: block;
      }

      .lcp {
        display: none;
      }

      .lcp.highlighted {
        display: block;
        z-index: 10;
        position: absolute;
        background-color: var(--highlight-color);
        opacity: 0.75;
      }

      .paint-rect {
        display: block;
        z-index: 10;
        position: absolute;
        opacity: 0.75;
      }
    </style>
    <div class="container">
      <img class="screenshot">
      <div class="lcp-container">
        <div class="lcp"></div>
        <filmstrip-tooltip id="lcp"></filmstrip-tooltip>
      </div>
      <div class="paint-rects-container"></div>
    </div>
  </template>
  <template id="timeline-event-icon">
    <style>
      .icon {
        width: 24px;
        height: 24px;
        flex-shrink: 0;
        background-color: var(--icon-color);
        position: relative;
      }
      
      /* Context created (Pointer for user interaction) */
      .icon-interaction {
        /*clip-path: polygon(25% 100%, 25% 40%, 30% 30%, 45% 15%, 50% 12%, 55% 15%, 70% 30%, 75% 40%, 75% 100%);*/
        clip-path: polygon(100% 34%, 69% 52%, 100% 80%, 80% 100%, 52% 69%, 34% 100%, 0 0);
      }

      /* DOM Modification (Document with folded corner) */
      .icon-dom-change {
        clip-path: polygon(15% 0%, 70% 0%, 100% 25%, 100% 100%, 15% 100%);
      }

      /* Content Painted (Detailed Paintbrush) */
      .icon-paint {
        clip-path: polygon(35% 0, 65% 0, 65% 45%, 85% 60%, 85% 100%, 15% 100%, 15% 60%, 35% 45%);
      }

      /* Soft navigation detected (Marker) */
      .icon-soft-nav-detected {
        clip-path: polygon(50% 0%, 82% 37%, 82% 100%, 18% 100%, 18% 37%);
      }

      /* LCP Candidate (Sharper Star) */
      .icon-lcp {
        clip-path: polygon(50% 0%, 63% 38%, 100% 38%, 75% 63%, 88% 100%, 50% 75%, 12% 100%, 25% 63%, 0% 38%, 37% 38%);
      }

      /* Context Exhausted (Curved Hourglass) */
      .icon-exhausted {
        clip-path: polygon(0 0, 100% 0, 100% 15%, 65% 45%, 65% 55%, 100% 85%, 100% 100%, 0 100%, 0 85%, 35% 55%, 35% 45%, 0 15%);
      }
    </style>
    <div class="icon"></div>
    <filmstrip-tooltip></filmstrip-tooltip>
  </template>
  <template id="timeline-events">
    <style>
      .container {
        background-color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px; /* Space between icons */
        min-height: 24px;
        padding: 4px; /* Add some padding so icons don't touch the edge */
      }

      timeline-event-icon {
        position: relative; /* For tooltip positioning */
        display: inline-block;
        --icon-color: #512DA8;
      }
    </style>
    <div class="container">
    </div>
  </template>
  <template id="timeline-timestamp">
    <style>
      .timestamp {
        font-family: sans-serif;
      }
    </style>
    <div class="timestamp"></div>
  </template>
  <template id="trace-timeline-template">
    <style>
      :host([empty]) {
        display: none;
      }

      .container {
        display: grid;
        font-family: sans-serif;
        background-color: black;
        color: white;
        overflow: hidden;
        padding: 15px;
        border-radius: 5px;
      }

      .container::-webkit-scrollbar {
        width: 10px;
        height: 10px;
      }

      .container::-webkit-scrollbar-thumb {
        background: #888;
        border-radius: 5px;
      }

      .container::-webkit-scrollbar-track {
        background-color: black;
      }

      .title {
        justify-self: start;
        font-size: x-large;
        padding: 10px 0 10px;
        grid-row-start: 1;
      }

      #timeline {
        display: grid;
        grid-row-start: 2;
        justify-items: center;
        justify-content: start;
        column-gap: 4px;
        row-gap: 4px;
        overflow-x: auto;
      }
      #timeline::-webkit-scrollbar {
        -webkit-appearance: none;
      }

      #timeline::-webkit-scrollbar:horizontal {
        height: 11px;
      }

      #timeline::-webkit-scrollbar-thumb {
        border-radius: 8px;
        border: 2px solid white;
        background-color: rgba(0, 0, 0, .5);
      }
      #timeline::-webkit-scrollbar-track { 
        background-color: #fff; 
        border-radius: 8px; 
      }

      #timeline[compressed]>filmstrip-screenshot:not([has-lcp]) {
        display: none;
      }

      #timeline[compressed]>filmstrip-screenshot:not([has-lcp])+timeline-timestamp {
        display: none;
      }

      input[type=checkbox] {
        margin: 10px;
      }

      label:hover {
        color: #2196F3;
      }

      label:hover>input {
        box-shadow: 0 0 3px 3px #2196F3;
      }

      filmstrip-screenshot {
        border: 3px solid yellow;
      }

      timeline-events {
        display: block;
        width: 100%;
      }
    </style>
    <div class="container">
      <h1 class="title"></h1>
      <div id="timeline"></div>
      <label for="hide-no-lcp"><input type="checkbox" id="hide-no-lcp">Hide screenshots that are not LCP
        candidates</label>
    </div>
  </template>
  <template id="drop-target-template">
    <style>
      .container {
        width: 100vw;
        height: 100vh;
        display: grid;
        place-content: center;
        font-family: sans-serif;
      }

      .container.secondary {
        width: fit-content;
        height: fit-content;
        padding: 20px;
      }

      #file-input {
        display: none;
      }

      .drop-target-content {
        border: 2px dashed;
        border-radius: 10px;
        width: 800px;
        height: 500px;
        display: grid;
        place-content: center;
        justify-items: center;
        padding: 20px;
      }

      .drop-target-content:hover {
        background-color: #2196F3;
      }

      .drop-target-content:hover #upload-icon {
        fill: white;
      }
      .drop-target-content:hover #instructions {
        color: white;
      }

      .secondary .drop-target-content {
        width: 200px;
        height: 200px;
      }

      .drop-icon {
        width: 200px;
        height: 200px;
      }

      .secondary .drop-icon {
        width: 100px;
        height: 100px;
      }

      .error .drop-target-content {
        background-color: #FFCDD2;
        color: #F44336;
        border-color: #D32F2F;
      }

      #drop-error {
        display: none;
      }

      .error #drop-error, #instructions {
        display: inline-block;
        font-size: xx-large;
        text-align: center;
        margin: 20px;
      }

      .secondary.error #drop-error, .secondary #instructions {
        font-size: medium;
      }

      .error #upload-icon {
        fill: #F44336 !important;
      }

      .error #instructions {
        display: none;
      }
    </style>
    <div class="container">
      <input id="file-input" type="file">
      <label for="file-input" class="drop-target-content">
        <svg class="drop-icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 -960 960 960">
          <path id="upload-icon"
            d="M440-320v-326L336-542l-56-58 200-200 200 200-56 58-104-104v326h-80ZM240-160q-33 0-56.5-23.5T160-240v-120h80v120h480v-120h80v120q0 33-23.5 56.5T720-160H240Z" />
        </svg>
        <div id="drop-error"></div>
        <div id="instructions">Record a trace, save it, and drop the .json file here.
          <a href="https://github.com/anniesullie/soft-navigation-trace-viewer/blob/main/README.md" target="_blank">Full instructions</a>.</div>
      </label>
    </div>
  </template>
  <script>

    const filmstripTooltipTemplateContent = document.getElementById("filmstrip-tooltip-template").content;
    const filmstripScreenshotTemplateContent = document.getElementById("filmstrip-screenshot-template").content;
    const timelineEventsTemplateContent = document.getElementById("timeline-events").content;
    const timelineEventIconTemplateContent = document.getElementById("timeline-event-icon").content;
    const timelineTimestampTemplateContent = document.getElementById("timeline-timestamp").content;
    const traceTimelineTemplateContent = document.getElementById("trace-timeline-template").content;
    const dropTargetTemplateContent = document.getElementById("drop-target-template").content;

    class FilmstripTooltip extends HTMLElement {
      #color;
      #values;

      connectedCallback() {
        const shadowRoot = this.attachShadow({ mode: "open" });
        shadowRoot.appendChild(filmstripTooltipTemplateContent.cloneNode(true));
        this.updateTooltip();
        this.updateColor();
      }

      set values(values) {
        this.#values = values;
        this.updateTooltip();
      }

      set color(color) {
        this.#color = color;
        this.updateColor();
      }

      updateColor() {
        if (!this.shadowRoot || !this.#color) {
          return;
        }
        this.style.setProperty('--color', this.#color);
      }

      set hover(hover) {
        if (!this.shadowRoot) {
          return;
        }
        if (hover) {
          this.shadowRoot.querySelector('.tooltip').classList.add('hover');
        } else {
          this.shadowRoot.querySelector('.tooltip').classList.remove('hover');
        }
      }

      get hoverSticky() {
        if (!this.shadowRoot) {
          return false;
        }
        return this.shadowRoot.querySelector('.tooltip').classList.contains('hoverSticky');
      }

      set hoverSticky(hoverSticky) {
        if (!this.shadowRoot) {
          return;
        }
        if (hoverSticky) {
          this.shadowRoot.querySelector('.tooltip').classList.add('hoverSticky');
        } else {
          this.shadowRoot.querySelector('.tooltip').classList.remove('hoverSticky');
        }
      }

      updateTooltip() {
        if (!this.shadowRoot || !this.#values) {
          return;
        }
        let tooltip = this.shadowRoot.querySelector('.tooltip');
        if (!tooltip) {
          return;
        }
        tooltip.classList.add('tooltip');
        let title = this.shadowRoot.querySelector('.title');
        title.textContent = this.#values.title;
        let gridElement = this.shadowRoot.querySelector('.data-grid');
        gridElement.replaceChildren();

        Object.entries(this.#values).forEach(([key, value]) => {
          if (key == 'title') {
            return;
          }
          let k = document.createElement('span');
          k.textContent = `${key}:`;
          k.classList.add('data-label');
          gridElement.appendChild(k);
          let v = document.createElement('span');
          v.classList.add('data-value');
          v.textContent = value;
          gridElement.appendChild(v);
        });
      }
    }

    class FilmstripScreenshot extends HTMLElement {
      #viewport;
      #lcpData;
      #src;
      #highlightColor;
      #paintRects;
      #final;

      connectedCallback() {
        const shadowRoot = this.attachShadow({ mode: "open" });
        shadowRoot.appendChild(filmstripScreenshotTemplateContent.cloneNode(true));
        this.updateSrc();
        this.updateHighlightColor();
      }

      set highlightColor(highlightColor) {
        this.#highlightColor = highlightColor;
        this.updateHighlightColor();
      }

      updateHighlightColor() {
        if (!this.shadowRoot || !this.#highlightColor) {
          return;
        }
        this.style.setProperty('--highlight-color', this.#highlightColor);
      }

      set viewport(viewport) {
        this.#viewport = viewport;
      }

      set lcpData(lcpData) {
        this.#lcpData = lcpData;
        this.updateLcpRect();
        this.setAttribute("has-lcp", "true");
      }

      set paintRects(paintRects) {
        this.#paintRects = paintRects;
        this.updatePaintRects();
      }

      set src(src) {
        this.#src = `data:image/png;base64,${src}`;
        this.updateSrc();
      }

      set final(final) {
        this.#final = final;
        this.updateLcpRect();
      }

      updateSrc() {
        if (!this.shadowRoot || !this.#src) {
          return;
        }
        let el = this.shadowRoot.querySelector('.screenshot');
        if (el) {
          el.src = this.#src;
          el.addEventListener('load', this.updateLcpRect.bind(this));
          el.addEventListener('load', this.updatePaintRects.bind(this));
        }
      }

      positionElement(left, top, width, height, element) {
        // Adjust to screenshot dimensions by converting to fraction of the
        //  viewport and multiplying by screenshot width and height.
        let img = this.shadowRoot.querySelector('.screenshot');
        left = (left / this.#viewport.width) * img.clientWidth;
        top = (top / this.#viewport.height) * img.clientHeight;
        width = (width / this.#viewport.width) * img.clientWidth;
        height = (height / this.#viewport.height) * img.clientHeight;
        element.style.top = `${top}px`;
        element.style.left = `${left}px`;
        element.style.width = `${width}px`;
        element.style.height = `${height}px`;
      }

      // TODO(sullivan): the LCP rect overlaps the paint rect. Maybe there should be one rect with two tooltips?
      updateLcpRect() {
        if (!this.shadowRoot || !this.#viewport || !this.#lcpData) {
          return;
        }
        this.highlightColor = CONTEXT_ID_HIGHLIGHT_COLORS[this.#lcpData['Context ID'] % CONTEXT_ID_HIGHLIGHT_COLORS.length];
        // Rect is p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y.
        let left = this.#lcpData.rect[0];
        let top = this.#lcpData.rect[1];
        let width = this.#lcpData.rect[2] - left;
        let height = this.#lcpData.rect[5] - top;
        let lcpElement = this.shadowRoot.querySelector('.lcp');
        this.positionElement(left, top, width, height, lcpElement);
        lcpElement.classList.add('highlighted');
        let tooltipValues = {
          'title': 'Largest Contentful Paint',
          'Type': this.#lcpData.type,
          'Size': this.#lcpData.size,
          'Context ID': this.#lcpData['Context ID'],
          'Navigation ID': this.#lcpData['Navigation ID'],
          'Timestamp': this.#lcpData.Timestamp,
          'URL': this.#lcpData.url
        };
        if (this.#final) {
          tooltipValues['Final'] = 'Final';
        }
        this.shadowRoot.querySelector('filmstrip-tooltip#lcp').values = tooltipValues;
      }

      updatePaintRects() {
        if (!this.shadowRoot || !this.#viewport || !this.#paintRects) {
          return;
        }
        let container = this.shadowRoot.querySelector('.paint-rects-container');
        if (!container) {
          return;
        }
        container.replaceChildren();
        for (let rect of this.#paintRects) {
          let wrapper = document.createElement('div');
          wrapper.style.position = 'absolute';
          this.positionElement(rect.x, rect.y, rect.width, rect.height, wrapper);

          let rectElement = document.createElement('div');
          rectElement.classList.add('paint-rect');
          // This doesn't use a CSS var because there could be multiple highlight colors from multiple contexts in a frame.
          rectElement.style.backgroundColor = CONTEXT_ID_HIGHLIGHT_COLORS[rect.contextId % CONTEXT_ID_HIGHLIGHT_COLORS.length];
          rectElement.style.width = '100%';
          rectElement.style.height = '100%';
          wrapper.appendChild(rectElement);
          let tooltipInfo = {title: 'Attributed Paint'};
          Object.entries(rect).forEach(([key, value]) => {
            if (['x', 'y', 'width', 'height'].includes(key)) {
              return;
            }
            tooltipInfo[key] = value;
          });
          let tooltip = document.createElement('filmstrip-tooltip');
          tooltip.values = tooltipInfo;
          tooltip.color = CONTEXT_ID_HIGHLIGHT_COLORS[rect.contextId % CONTEXT_ID_HIGHLIGHT_COLORS.length];
          wrapper.appendChild(tooltip);

          rectElement.addEventListener('mouseenter', () => tooltip.hover = true);
          rectElement.addEventListener('mouseleave', () => tooltip.hover = false);
          rectElement.addEventListener('click', () => tooltip.hoverSticky = !tooltip.hoverSticky);

          container.appendChild(wrapper);
        }
      }
    }

    class TimelineEventIcon extends HTMLElement {
      #event;
      #tooltipContent;
      #iconColor;

      constructor() {
        super();
      }

      connectedCallback() {
        const shadowRoot = this.attachShadow({ mode: "open" });
        shadowRoot.appendChild(timelineEventIconTemplateContent.cloneNode(true));
        this.updateEvent();
        this.updateTooltipContent();
        this.updateIconColor();
        this.shadowRoot.querySelector('.icon').addEventListener('mouseenter', () => this.shadowRoot.querySelector('filmstrip-tooltip').hover = true);
        this.shadowRoot.querySelector('.icon').addEventListener('mouseleave', () => this.shadowRoot.querySelector('filmstrip-tooltip').hover = false);
        this.addEventListener('click', () => this.shadowRoot.querySelector('filmstrip-tooltip').hoverSticky = !this.shadowRoot.querySelector('filmstrip-tooltip').hoverSticky);
      }

      disconnectedCallback() {
        this.removeEventListener('click');
        this.shadowRoot.querySelector('icon').removeEventListener('mouseenter');
        this.shadowRoot.querySelector('icon').removeEventListener('mouseleave');
      }

      set iconColor(iconColor) {
        this.#iconColor = iconColor;
        this.updateIconColor();
      }

      set event(event) {
        this.#event = event;
        this.updateEvent();
      }

      set tooltipContent(tooltipContent) {
        this.#tooltipContent = tooltipContent;
        this.updateTooltipContent();
      }

      updateEvent() {
        if (!this.shadowRoot || !this.#event) {
          return;
        }
        let el = this.shadowRoot.querySelector('.icon');
        if (el) {
          el.classList.add(`icon-${this.#event}`);
        }
      }

      updateTooltipContent() {
        if (!this.shadowRoot || !this.#tooltipContent) {
          return;
        }
        let tooltip = this.shadowRoot.querySelector('filmstrip-tooltip');
        if (!tooltip) {
          return;
        }
        tooltip.values = this.#tooltipContent;
      }

      updateIconColor() {
        if (!this.shadowRoot || !this.#iconColor) {
          return;
        }
        this.style.setProperty('--icon-color', this.#iconColor);
        this.shadowRoot.querySelector('filmstrip-tooltip').color = this.#iconColor;
      }
    }

    class TimelineEvents extends HTMLElement {
      #icons = [];

      connectedCallback() {
        const shadowRoot = this.attachShadow({ mode: "open" });
        shadowRoot.appendChild(timelineEventsTemplateContent.cloneNode(true));
        this.updateIcons();
      }

      addIcon(icon) {
        this.#icons.push(icon);
        this.updateIcons();
      }

      updateIcons() {
        if (!this.shadowRoot || this.#icons == null) {
          return;
        }
        let container = this.shadowRoot.querySelector('.container');
        container.replaceChildren();
        for (let icon of this.#icons) {
          container.appendChild(icon);
        }
      }

    }

    class TimelineTimestamp extends HTMLElement {
      #timestamp;

      connectedCallback() {
        const shadowRoot = this.attachShadow({ mode: "open" });
        shadowRoot.appendChild(timelineTimestampTemplateContent.cloneNode(true));
        this.updateTimestamp();
      }

      set timestamp(timestamp) {
        this.#timestamp = timestamp;
        this.updateTimestamp();
      }

      updateTimestamp() {
        if (!this.shadowRoot || this.#timestamp == null) {
          return;
        }
        let el = this.shadowRoot.querySelector('.timestamp');
        if (el) {
          el.textContent = this.#timestamp;
        }
      }

    }

    const TRACE_EVENT_NAMES = {
      SCREENSHOT: 'Screenshot',
      LCP_CANDIDATE: 'largestContentfulPaint::Candidate',
      SOFT_NAV_DETECTED: 'SoftNavigationHeuristics_SoftNavigationDetected',
      TRACING_STARTED: 'TracingStartedInBrowser',
      VIEWPORT: 'PaintTimingVisualizer::Viewport',
      LAYOUT_OBJECT_PAINTED: 'PaintTimingVisualizer::LayoutObjectPainted',
      SOFT_NAV_CONSTRUCTOR: "SoftNavigationHeuristics::SoftNavigation",
      SOFT_NAV_CONTEXT_FIRST_MODIFIED_NODE: "SoftNavigationContext::FirstAddedModifiedNodeInAnimationFrame",
      SOFT_NAV_CONTEXT_MODIFIED_NODE: "SoftNavigationContext::AddedModifiedNodeInAnimationFrame",
      SOFT_NAV_CONTEXT_FIRST_PAINT_IN_FRAME: "SoftNavigationContext::FirstAttributablePaintInAnimationFrame",
      SOFT_NAV_CONTEXT_PAINT_IN_FRAME: "SoftNavigationContext::AttributablePaintInAnimationFrame",
      SOFT_NAV_CONTEXT_EXHAUSTED: 'SoftNavigationHeuristics::SoftNavigationContextWasExhausted'
    }

    class TraceTimeline extends HTMLElement {
      connectedCallback() {
        const shadowRoot = this.attachShadow({ mode: "open" });
        shadowRoot.appendChild(traceTimelineTemplateContent.cloneNode(true));
        shadowRoot.querySelector('#hide-no-lcp').addEventListener('change', this.onchange.bind(this));
      }

      onchange(event) {
        const isChecked = event.target.checked;
        this.shadowRoot.querySelector('#timeline').toggleAttribute('compressed', isChecked);
      }

      #setGridCss(element, row, column) {
        element.style.gridRowStart = row;
        element.style.gridColumnStart = column;
      }

      set title(title) {
        this.shadowRoot.querySelector('.title').textContent = title;
      }

      getTooltipContent(title, args, navigationId, adjustedTimestamp) {
        return {
            'title': title,
            'URL': args?.context?.mostRecentURL,
            'Navigation ID': navigationId,
            'Context ID': args?.context?.softNavContextId,
            'DOM Modifications': args?.context?.domModifications,
            'Painted Area': args?.context?.paintedArea,
            'Timestamp': adjustedTimestamp,
        };
      }

      createIcon(event, tooltipContent, contextId) {
        let icon = document.createElement('timeline-event-icon');
        icon.event = event;
        icon.tooltipContent = tooltipContent;
        icon.iconColor = CONTEXT_ID_COLORS[contextId % CONTEXT_ID_COLORS.length];
        icon.timestamp = tooltipContent['Timestamp'];
        return icon;
      }

      set traceData(traceData) {
        // Clear previous timeline
        this.removeAttribute('empty');
        let timelineContainer = this.shadowRoot.querySelector('#timeline');
        timelineContainer.replaceChildren();
        // Parse trase JSON from text data
        let traceJson = JSON.parse(traceData);
        let traceEvents = traceJson.traceEvents;
        traceEvents.sort((a, b) => a.ts - b.ts);
        // Tracing Started event has original URL in args.data.frames[0].url
        let traceStartedEvent = traceEvents.find((e) => e.name == TRACE_EVENT_NAMES.TRACING_STARTED);
        let startUrl = traceStartedEvent?.args?.data?.frames?.[0]?.url ?? 'Unknown URL';

        this.title = `Soft navigations from ${startUrl}`;
        // Find viewport rect
        let viewportEvent = traceEvents.find((e) => e.name == TRACE_EVENT_NAMES.VIEWPORT);
        if (!viewportEvent) {
          throw new Error('No PaintTimingVisualizer::Viewport event in trace.');
        }
        let viewport = {
          width: viewportEvent.args.data.viewport_rect[2], // x2
          height: viewportEvent.args.data.viewport_rect[5] // y3 (assuming rect is x1,y1,x2,y1,x2,y2,x1,y2)
        };
        // Cache paint events for LCP candidate nodes
        let lcpNodeIds = new Set(traceEvents.flatMap(e =>
          (e.name === TRACE_EVENT_NAMES.LCP_CANDIDATE && e.args?.data?.nodeId) ? [e.args.data.nodeId] : []
        ));
        let lcpPaintEvents = traceEvents.filter(e =>
          e.name === TRACE_EVENT_NAMES.LAYOUT_OBJECT_PAINTED && e.args?.data && lcpNodeIds.has(e.args.data.dom_node_id)
        );
        // Filter to relevant trace events
        traceEvents = traceEvents.filter((e) => [
          TRACE_EVENT_NAMES.SCREENSHOT,
          TRACE_EVENT_NAMES.LCP_CANDIDATE,
          TRACE_EVENT_NAMES.SOFT_NAV_CONSTRUCTOR,
          TRACE_EVENT_NAMES.SOFT_NAV_DETECTED,
          TRACE_EVENT_NAMES.SOFT_NAV_CONTEXT_FIRST_MODIFIED_NODE,
          TRACE_EVENT_NAMES.SOFT_NAV_CONTEXT_MODIFIED_NODE,
          TRACE_EVENT_NAMES.SOFT_NAV_CONTEXT_FIRST_PAINT_IN_FRAME,
          TRACE_EVENT_NAMES.SOFT_NAV_CONTEXT_PAINT_IN_FRAME,
          TRACE_EVENT_NAMES.SOFT_NAV_CONTEXT_EXHAUSTED
        ].includes(e.name));
        // Find the first soft navigation event.
        let firstSoftNavIndex = traceEvents.findIndex((e) => e.name == TRACE_EVENT_NAMES.SOFT_NAV_DETECTED);
        if (firstSoftNavIndex == -1) {
          throw new Error('No soft navigations found in trace!');
        }
        // Clip frames to the first one before the soft nav.
        let index = 0;
        for (index = firstSoftNavIndex - 1; index >= 0; index--) {
          if (traceEvents[index].name == TRACE_EVENT_NAMES.SCREENSHOT) {
            break;
          }
        }
        traceEvents.splice(0, index);
        let timeStart = traceEvents[0].ts;
        let lastSnapshot = null;
        let column = 1;
        let lastSoftNavId = null;
        let nextIcons = [];
        let nextLcpData = null;
        let nextDomModifications = [];
        let nextPaints = [];
        let lastLcpCandidateScreenshot = null;
        let navigationIdToContextId = {};
        for (let e of traceEvents) {
          let eventsElement = document.createElement('timeline-events');
          this.#setGridCss(eventsElement, 2, column);
          let adjustedTimestamp = Math.floor((e.ts - timeStart) / 1000);
          let timestampElement = document.createElement('timeline-timestamp');
          timestampElement.timestamp = adjustedTimestamp;
          this.#setGridCss(timestampElement, 3, column);
          if (e.name == TRACE_EVENT_NAMES.SOFT_NAV_CONSTRUCTOR) {
            if (!e.args?.context) {
              continue;
            }
            nextIcons.push(this.createIcon(
              'interaction',
              this.getTooltipContent('Soft Navigation Constructor', e.args, e.args.navigationId, adjustedTimestamp),
              e.args?.context?.softNavContextId));
            continue;
          } else if (e.name == TRACE_EVENT_NAMES.SOFT_NAV_DETECTED) {
            lastSoftNavId = e.args.navigationId;
            let contextId = e.args?.context?.softNavContextId;
            navigationIdToContextId[lastSoftNavId] = contextId;
            nextIcons.push(this.createIcon(
              'soft-nav-detected',
              this.getTooltipContent('Soft Navigation Detected', e.args, lastSoftNavId, adjustedTimestamp),
              contextId));
            if (lastLcpCandidateScreenshot) {
              lastLcpCandidateScreenshot.final = "true";
              lastLcpCandidateScreenshot = null;
            }
            continue;
          } else if (e.name == TRACE_EVENT_NAMES.SOFT_NAV_CONTEXT_FIRST_MODIFIED_NODE || e.name == TRACE_EVENT_NAMES.SOFT_NAV_CONTEXT_MODIFIED_NODE) {
            nextDomModifications.push({
              'timestamp': adjustedTimestamp,
              'contextId': e.args?.context?.softNavContextId,
              'nodeDebugName': e.args?.nodeDebugName,
              'nodeId': e.args?.nodeId,
            });
            continue;
          } else if (e.name == TRACE_EVENT_NAMES.SOFT_NAV_CONTEXT_FIRST_PAINT_IN_FRAME || e.name == TRACE_EVENT_NAMES.SOFT_NAV_CONTEXT_PAINT_IN_FRAME) {
            nextPaints.push({
              'timestamp': adjustedTimestamp,
              'contextId': e.args?.context?.softNavContextId,
              'nodeDebugName': e.args?.nodeDebugName,
              'nodeId': e.args?.nodeId,
              'x': e.args?.rect_x,
              'y': e.args?.rect_y,
              'width': e.args?.rect_width,
              'height': e.args?.rect_height
            });
            continue;
          } else if (e.name == TRACE_EVENT_NAMES.SOFT_NAV_CONTEXT_EXHAUSTED) {
            nextIcons.push(this.createIcon(
              'exhausted',
              this.getTooltipContent('Soft Context Exhausted', e.args, lastSoftNavId, adjustedTimestamp),
              e.args?.context?.softNavContextId));
            continue;
          } else if (e.name == TRACE_EVENT_NAMES.LCP_CANDIDATE) {
            let contextId = navigationIdToContextId[e.args.data.navigationId];
            if (!contextId) {
              // LCP unrelated to soft navs in this trace.
              continue;
            }
            // Get related paint event with same node id for text/image placement data
            let paintEvent = lcpPaintEvents.find(p => p.args?.data?.dom_node_id === e.args.data.nodeId);
            if (!paintEvent) {
              console.warn(`No paint event for LCP with node id ${e.args.data.nodeId}`);
              continue;
            }
            nextLcpData = {
              'rect': paintEvent.args.data.rect,
              'url': paintEvent.args.data.image_url,
              'size': e.args.data.size,
              'type': e.args.data.type,
              'Context ID': contextId,
              'Navigation ID': e.args.data.navigationId,
              'Timestamp': adjustedTimestamp,
            };
            nextIcons.push(this.createIcon(
              'lcp',
              this.getTooltipContent('Largest Contentful Paint', {context: {'softNavContextId': contextId}}, e.args.navigationId, adjustedTimestamp),
              contextId));
            continue;
          } else if (e.name == TRACE_EVENT_NAMES.SCREENSHOT) {
            let snapshot = e.args.snapshot;
            if (snapshot == lastSnapshot) {
              // Nothing new painted.
              continue;
            }
            lastSnapshot = snapshot;
            let screenshotElement = document.createElement("filmstrip-screenshot");
            screenshotElement.src = lastSnapshot;
            screenshotElement.viewport = viewport;
            if (nextLcpData) {
              screenshotElement.lcpData = nextLcpData;
              nextLcpData = null;
              lastLcpCandidateScreenshot = screenshotElement;
            }
            if (nextDomModifications.length > 0) {
              const groupedByContextId = Object.groupBy(nextDomModifications, obj => obj.contextId);
              for (const contextId in groupedByContextId) {
                let modificationsForContext = groupedByContextId[contextId];
                nextIcons.push(this.createIcon(
                  'dom-change',
                  {
                      'title': 'DOM Modifications',
                      'Context ID': contextId,
                      'Node IDs': modificationsForContext.map(node => node.nodeId).join(','),
                      'Node Debug Names': modificationsForContext.map(node => node.nodeDebugName).join('\n'),
                      'Timestamp': modificationsForContext[0].timestamp
                  },
                  contextId
                ));
              }
              nextDomModifications = [];
            }
            if (nextPaints.length > 0) {
              screenshotElement.paintRects = nextPaints;
              const groupedByContextId = Object.groupBy(nextPaints, obj => obj.contextId);
              for (const contextId in groupedByContextId) {
                let paintsForContext = groupedByContextId[contextId];
                nextIcons.push(this.createIcon(
                  'paint',
                  {
                      'title': 'Paint Attributed',
                      'Context ID': contextId,
                      'Node IDs': paintsForContext.map(node => node.nodeId).join(','),
                      'Node Debug Names': paintsForContext.map(node => node.nodeDebugName).join('\n'),
                      'Timestamp': paintsForContext[0].timestamp
                  },
                  contextId
                ));
              }
              nextPaints = [];
            }
            this.#setGridCss(screenshotElement, 1, column);
            timelineContainer.append(screenshotElement);
          }
          nextIcons.sort((a, b) => a.timestamp - b.timestamp);
          for (let eventIcon of nextIcons) {
            eventsElement.addIcon(eventIcon);
          }
          nextIcons = [];
          timelineContainer.appendChild(eventsElement);
          timelineContainer.appendChild(timestampElement);
          column = column + 1;
        }
        if (lastLcpCandidateScreenshot) {
          lastLcpCandidateScreenshot.final = true;
          lastLcpCandidateScreenshot = null;
        }
      }
    }

    class DropTarget extends HTMLElement {
      connectedCallback() {
        const shadowRoot = this.attachShadow({ mode: "open" });
        shadowRoot.appendChild(dropTargetTemplateContent.cloneNode(true));

        shadowRoot.querySelector(".drop-target-content").addEventListener("dragover", this.handleDragover.bind(this));
        shadowRoot.querySelector(".drop-target-content").addEventListener("drop", this.handleDrop.bind(this));
        shadowRoot.querySelector("#file-input").addEventListener("change", this.handleChange.bind(this));
      }

      handleDragover(event) {
        event.preventDefault();
      }

      handleDrop(event) {
        event.preventDefault();
        this.clearDropError();

        let textPromise = null;
        if (event.dataTransfer.items) {
          // Use DataTransferItemList interface to access the file(s)
          [...event.dataTransfer.items].forEach((item, i) => {
            // If dropped items aren't files, reject them
            if (item.kind === "file") {
              const file = item.getAsFile();
              textPromise = file.text();
            }
          });
        } else {
          // Use DataTransfer interface to access the file(s)
          [...event.dataTransfer.files].forEach((file, i) => {
            textPromise = file.text();
          });
        }
        if (!textPromise) {
          this.showDropError('No trace file dropped');
          return;
        }
        textPromise.then(this.generateTimeline.bind(this)).catch(this.showDropError.bind(this));
      }

      handleChange(event) {
        let file = event.target.files[0];
        file.text().then(this.generateTimeline.bind(this)).catch(this.showDropError.bind(this));
      }

      generateTimeline(text) {
        document.querySelector('trace-timeline').traceData = text;
        this.shadowRoot.querySelector('.container').classList.add('secondary');
      }

      showDropError(message) {
        console.error(message);
        document.querySelector('trace-timeline').setAttribute('empty', 'true');
        this.shadowRoot.querySelector('#drop-error').textContent = message;
        this.shadowRoot.querySelector('.container').classList.add('error');
        this.shadowRoot.querySelector('.container').classList.remove('secondary');
      }

      clearDropError() {
        this.shadowRoot.querySelector('#drop-error').textContent = '';
        this.shadowRoot.querySelector('.container').classList.remove('error');
      }
    }

    customElements.define(
      "filmstrip-tooltip",
      FilmstripTooltip,
    );
    customElements.define(
      "drop-target",
      DropTarget,
    );
    customElements.define(
      "trace-timeline",
      TraceTimeline,
    );
    customElements.define(
      "timeline-event-icon",
      TimelineEventIcon,
    );
    customElements.define(
      "timeline-events",
      TimelineEvents,
    );
    customElements.define(
      "timeline-timestamp",
      TimelineTimestamp,
    );
    customElements.define(
      "filmstrip-screenshot",
      FilmstripScreenshot
    );
  </script>
  <trace-timeline empty></trace-timeline>
  <drop-target></drop-target>
</body>
</html>
